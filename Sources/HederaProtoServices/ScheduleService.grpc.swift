//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: ScheduleService.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import SwiftProtobuf


///
///Transactions and queries for the Schedule Service
///The Schedule Service allows transactions to be submitted without all the required signatures and allows anyone to provide the required signatures independently after a transaction has already been created.
///Execution:
///Scheduled Transactions are executed once all required signatures are collected and witnessed. Every time new signature is provided, a check is performed on the "readiness" of the execution.
///The Scheduled Transaction will be executed immediately after the transaction that triggered it and will be externalised in a separate Transaction Record.
///Transaction Record:
///The timestamp of the Scheduled Transaction will be equal to consensusTimestamp + 1 nano, where consensusTimestamp is the timestamp of the transaction that triggered the execution.
///The Transaction ID of the Scheduled Transaction will have the scheduled property set to true and inherit the transactionValidStart and accountID from the ScheduleCreate transaction.
///The scheduleRef property of the transaction record will be populated with the ScheduleID of the Scheduled Transaction.
///Post execution:
///Once a given Scheduled Transaction executes, it will be removed from the ledger and any upcoming operation referring the ScheduleID will resolve to INVALID_SCHEDULE_ID.
///Expiry:
///Scheduled Transactions have a global expiry time txExpiryTimeSecs (Currently set to 30 minutes). If txExpiryTimeSecs pass and the Scheduled Transaction haven't yet executed, it will be removed from the ledger as if ScheduleDelete operation is executed.
///
/// Usage: instantiate `Proto_ScheduleServiceClient`, then call methods of this protocol to make API calls.
public protocol Proto_ScheduleServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Proto_ScheduleServiceClientInterceptorFactoryProtocol? { get }

  func createSchedule(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func signSchedule(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func deleteSchedule(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func getScheduleInfo(
    _ request: Proto_Query,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Query, Proto_Response>
}

extension Proto_ScheduleServiceClientProtocol {
  public var serviceName: String {
    return "proto.ScheduleService"
  }

  /// Creates a new Schedule by submitting the transaction
  ///
  /// - Parameters:
  ///   - request: Request to send to createSchedule.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func createSchedule(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: "/proto.ScheduleService/createSchedule",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecreateScheduleInterceptors() ?? []
    )
  }

  /// Signs a new Schedule by submitting the transaction
  ///
  /// - Parameters:
  ///   - request: Request to send to signSchedule.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func signSchedule(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: "/proto.ScheduleService/signSchedule",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesignScheduleInterceptors() ?? []
    )
  }

  /// Deletes a new Schedule by submitting the transaction
  ///
  /// - Parameters:
  ///   - request: Request to send to deleteSchedule.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func deleteSchedule(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: "/proto.ScheduleService/deleteSchedule",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedeleteScheduleInterceptors() ?? []
    )
  }

  /// Retrieves the metadata of a schedule entity
  ///
  /// - Parameters:
  ///   - request: Request to send to getScheduleInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getScheduleInfo(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Query, Proto_Response> {
    return self.makeUnaryCall(
      path: "/proto.ScheduleService/getScheduleInfo",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetScheduleInfoInterceptors() ?? []
    )
  }
}

public protocol Proto_ScheduleServiceClientInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when invoking 'createSchedule'.
  func makecreateScheduleInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'signSchedule'.
  func makesignScheduleInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'deleteSchedule'.
  func makedeleteScheduleInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'getScheduleInfo'.
  func makegetScheduleInfoInterceptors() -> [ClientInterceptor<Proto_Query, Proto_Response>]
}

public final class Proto_ScheduleServiceClient: Proto_ScheduleServiceClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Proto_ScheduleServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the proto.ScheduleService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Proto_ScheduleServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

///
///Transactions and queries for the Schedule Service
///The Schedule Service allows transactions to be submitted without all the required signatures and allows anyone to provide the required signatures independently after a transaction has already been created.
///Execution:
///Scheduled Transactions are executed once all required signatures are collected and witnessed. Every time new signature is provided, a check is performed on the "readiness" of the execution.
///The Scheduled Transaction will be executed immediately after the transaction that triggered it and will be externalised in a separate Transaction Record.
///Transaction Record:
///The timestamp of the Scheduled Transaction will be equal to consensusTimestamp + 1 nano, where consensusTimestamp is the timestamp of the transaction that triggered the execution.
///The Transaction ID of the Scheduled Transaction will have the scheduled property set to true and inherit the transactionValidStart and accountID from the ScheduleCreate transaction.
///The scheduleRef property of the transaction record will be populated with the ScheduleID of the Scheduled Transaction.
///Post execution:
///Once a given Scheduled Transaction executes, it will be removed from the ledger and any upcoming operation referring the ScheduleID will resolve to INVALID_SCHEDULE_ID.
///Expiry:
///Scheduled Transactions have a global expiry time txExpiryTimeSecs (Currently set to 30 minutes). If txExpiryTimeSecs pass and the Scheduled Transaction haven't yet executed, it will be removed from the ledger as if ScheduleDelete operation is executed.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Proto_ScheduleServiceProvider: CallHandlerProvider {
  var interceptors: Proto_ScheduleServiceServerInterceptorFactoryProtocol? { get }

  /// Creates a new Schedule by submitting the transaction
  func createSchedule(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  /// Signs a new Schedule by submitting the transaction
  func signSchedule(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  /// Deletes a new Schedule by submitting the transaction
  func deleteSchedule(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  /// Retrieves the metadata of a schedule entity
  func getScheduleInfo(request: Proto_Query, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_Response>
}

extension Proto_ScheduleServiceProvider {
  public var serviceName: Substring { return "proto.ScheduleService" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "createSchedule":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makecreateScheduleInterceptors() ?? [],
        userFunction: self.createSchedule(request:context:)
      )

    case "signSchedule":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makesignScheduleInterceptors() ?? [],
        userFunction: self.signSchedule(request:context:)
      )

    case "deleteSchedule":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makedeleteScheduleInterceptors() ?? [],
        userFunction: self.deleteSchedule(request:context:)
      )

    case "getScheduleInfo":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Query>(),
        responseSerializer: ProtobufSerializer<Proto_Response>(),
        interceptors: self.interceptors?.makegetScheduleInfoInterceptors() ?? [],
        userFunction: self.getScheduleInfo(request:context:)
      )

    default:
      return nil
    }
  }
}

public protocol Proto_ScheduleServiceServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'createSchedule'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makecreateScheduleInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'signSchedule'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makesignScheduleInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'deleteSchedule'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makedeleteScheduleInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'getScheduleInfo'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makegetScheduleInfoInterceptors() -> [ServerInterceptor<Proto_Query, Proto_Response>]
}
